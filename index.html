<!DOCTYPE html>
<html lang="en" data-theme="fittrack">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>FitTrack</title>

  <!-- PWA Config -->
  <link rel="manifest" href="manifest.json">
  <meta name="theme-color" content="#6366f1">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="FitTrack">
  <link rel="apple-touch-icon" href="icon.svg">
  <link rel="icon" type="image/svg+xml" href="icon.svg">
  
  <!-- Tailwind & DaisyUI -->
  <link href="https://cdn.jsdelivr.net/npm/daisyui@4.7.2/dist/full.min.css" rel="stylesheet" type="text/css" />
  <script src="https://cdn.tailwindcss.com"></script>
  
  <!-- Vue 3 (Production) -->
  <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
  <script src="https://unpkg.com/vue-demi"></script>
  <script src="https://unpkg.com/vue-router@4/dist/vue-router.global.prod.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/axios/1.6.2/axios.min.js"></script>
  <!-- Pinia -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pinia/2.1.7/pinia.iife.min.js"></script>

  <!-- Vercel Analytics -->
  <script type="module">
    import { inject } from 'https://cdn.jsdelivr.net/npm/@vercel/analytics/+esm';
    inject();
  </script>
  <script type="text/x-template" id="preference-selector-template">
    <div v-if="isOpen" class="fixed inset-0 z-[70] flex items-end justify-center sm:items-center">
        <div class="absolute inset-0 bg-black/60 backdrop-blur-sm transition-opacity" @click="close"></div>
        <div class="relative w-full max-w-lg bg-base-100 rounded-t-[2.5rem] sm:rounded-[2.5rem] p-6 shadow-2xl transform transition-transform animate-slide-up h-[70vh] flex flex-col">
            <div class="w-12 h-1.5 bg-base-300 rounded-full mx-auto mb-6 opacity-50 flex-shrink-0"></div>
            <div class="flex justify-between items-center mb-4 flex-shrink-0">
                <h3 class="text-xl font-black text-base-content">Ê∑ªÂä†{{ category }}ËÆ≠ÁªÉ</h3>
                <button class="btn btn-sm btn-circle btn-ghost" @click="close">‚úï</button>
            </div>
            
            <div class="flex-1 overflow-y-auto scrollbar-hide grid grid-cols-3 gap-3 content-start pb-24">
                <button 
                    v-for="action in actions" 
                    :key="action.id"
                    @click="toggle(action.id)"
                    class="flex flex-col items-center justify-center p-3 rounded-2xl transition-all border-2 relative h-28"
                    :class="isSelected(action.id) ? 'bg-primary/10 border-primary' : 'bg-base-200 border-transparent opacity-60 hover:opacity-100'"
                >
                    <div class="text-3xl mb-2">{{ action.icon }}</div>
                    <div class="text-xs font-bold text-center leading-tight line-clamp-2">{{ action.label }}</div>
                    <div v-if="isSelected(action.id)" class="absolute top-2 right-2 text-primary bg-white rounded-full w-4 h-4 flex items-center justify-center text-[10px] shadow-sm">‚úì</div>
                </button>
                <div v-if="actions.length === 0" class="col-span-3 text-center py-10 text-base-content/40">
                    ÊöÇÊó†Ê≠§Á±ªÂä®‰Ωú
                </div>
            </div>

            <div class="absolute bottom-0 left-0 w-full p-6 bg-gradient-to-t from-base-100 via-base-100 to-transparent">
                <button 
                    class="btn btn-primary btn-lg w-full rounded-2xl font-bold shadow-xl shadow-primary/20" 
                    @click="save"
                    :disabled="loading"
                >
                    <span v-if="loading" class="loading loading-spinner"></span>
                    <span v-else>‰øùÂ≠òËÆæÁΩÆ</span>
                </button>
            </div>
        </div>
    </div>
  </script>

  <!-- TEMPLATE: Height/Weight Modal -->
  <script type="text/x-template" id="hw-modal-template">
    <div v-if="isOpen" class="fixed inset-0 z-[80] flex items-center justify-center">
        <div class="absolute inset-0 bg-black/60 backdrop-blur-sm"></div>
        <div class="relative w-full max-w-sm mx-6 bg-base-100 rounded-3xl p-6 shadow-2xl animate-slide-up">
            <h3 class="text-xl font-black text-base-content mb-2 text-center">ÂÆåÂñÑ‰∏™‰∫∫‰ø°ÊÅØ</h3>
            <p class="text-sm text-base-content/60 text-center mb-6">‰∏∫‰∫ÜÊõ¥Á≤æÂáÜÂú∞ËÆ°ÁÆóÁÉ≠ÈáèÊ∂àËÄóÔºåËØ∑Ë°•ÂÖÖÊÇ®ÁöÑË∫´‰ΩìÊï∞ÊçÆ„ÄÇ</p>
            
            <div class="space-y-4">
                <div class="form-control">
                    <label class="label">
                        <span class="label-text font-bold">Ë∫´È´ò (cm)</span>
                    </label>
                    <input type="number" v-model="height" placeholder="‰æãÂ¶Ç: 175" class="input input-bordered w-full rounded-xl bg-base-200 focus:bg-base-100 transition-all" />
                </div>
                
                <div class="form-control">
                    <label class="label">
                        <span class="label-text font-bold">‰ΩìÈáç (kg)</span>
                    </label>
                    <input type="number" v-model="weight" placeholder="‰æãÂ¶Ç: 70" class="input input-bordered w-full rounded-xl bg-base-200 focus:bg-base-100 transition-all" />
                </div>
            </div>

            <div class="mt-8">
                <button 
                    class="btn btn-primary w-full rounded-xl font-bold shadow-lg shadow-primary/30" 
                    @click="save" 
                    :disabled="loading || !isValid"
                >
                    <span v-if="loading" class="loading loading-spinner"></span>
                    <span v-else>‰øùÂ≠ò‰ø°ÊÅØ</span>
                </button>
            </div>
        </div>
    </div>
  </script>

  <script>
    tailwind.config = {
      theme: {
        extend: {},
      },
      daisyui: {
        themes: [
          {
            fittrack: {
              "primary": "#6366f1",
              "secondary": "#ec4899",
              "accent": "#8b5cf6",
              "neutral": "#1f2937",
              "base-100": "#ffffff",
              "base-200": "#f3f4f6",
              "base-300": "#e5e7eb",
              "info": "#3abff8",
              "success": "#36d399",
              "warning": "#fbbd23",
              "error": "#f87272",
              "--rounded-box": "1rem",
              "--rounded-btn": "0.8rem",
              "--rounded-badge": "1.9rem",
              "--animation-btn": "0.25s",
              "--animation-input": "0.2s",
              "--btn-focus-scale": "0.95",
              "--border-btn": "1px",
              "--tab-border": "1px",
              "--tab-radius": "0.5rem",
            },
            red: {
              "primary": "#ef4444",
              "secondary": "#f87171",
              "accent": "#b91c1c",
              "neutral": "#1f2937",
              "base-100": "#ffffff",
              "base-200": "#fef2f2",
              "base-300": "#fee2e2",
              "info": "#3abff8",
              "success": "#36d399",
              "warning": "#fbbd23",
              "error": "#f87272",
              "--rounded-box": "1rem",
              "--rounded-btn": "0.8rem",
              "--rounded-badge": "1.9rem",
              "--animation-btn": "0.25s",
              "--animation-input": "0.2s",
              "--btn-focus-scale": "0.95",
              "--border-btn": "1px",
              "--tab-border": "1px",
              "--tab-radius": "0.5rem",
            },
            black: {
              "primary": "#1f2937",
              "secondary": "#374151",
              "accent": "#000000",
              "neutral": "#111827",
              "base-100": "#ffffff",
              "base-200": "#f3f4f6",
              "base-300": "#e5e7eb",
              "info": "#3abff8",
              "success": "#36d399",
              "warning": "#fbbd23",
              "error": "#f87272",
              "--rounded-box": "1rem",
              "--rounded-btn": "0.8rem",
              "--rounded-badge": "1.9rem",
              "--animation-btn": "0.25s",
              "--animation-input": "0.2s",
              "--btn-focus-scale": "0.95",
              "--border-btn": "1px",
              "--tab-border": "1px",
              "--tab-radius": "0.5rem",
            },
            green: {
              "primary": "#10b981",
              "secondary": "#34d399",
              "accent": "#059669",
              "neutral": "#1f2937",
              "base-100": "#ffffff",
              "base-200": "#ecfdf5",
              "base-300": "#d1fae5",
              "info": "#3abff8",
              "success": "#36d399",
              "warning": "#fbbd23",
              "error": "#f87272",
              "--rounded-box": "1rem",
              "--rounded-btn": "0.8rem",
              "--rounded-badge": "1.9rem",
              "--animation-btn": "0.25s",
              "--animation-input": "0.2s",
              "--btn-focus-scale": "0.95",
              "--border-btn": "1px",
              "--tab-border": "1px",
              "--tab-radius": "0.5rem",
            },
            blue: {
              "primary": "#3b82f6",
              "secondary": "#60a5fa",
              "accent": "#2563eb",
              "neutral": "#1f2937",
              "base-100": "#ffffff",
              "base-200": "#eff6ff",
              "base-300": "#dbeafe",
              "info": "#3abff8",
              "success": "#36d399",
              "warning": "#fbbd23",
              "error": "#f87272",
              "--rounded-box": "1rem",
              "--rounded-btn": "0.8rem",
              "--rounded-badge": "1.9rem",
              "--animation-btn": "0.25s",
              "--animation-input": "0.2s",
              "--btn-focus-scale": "0.95",
              "--border-btn": "1px",
              "--tab-border": "1px",
              "--tab-radius": "0.5rem",
            },
            orange: {
              "primary": "#f97316",
              "secondary": "#fb923c",
              "accent": "#ea580c",
              "neutral": "#1f2937",
              "base-100": "#ffffff",
              "base-200": "#fff7ed",
              "base-300": "#ffedd5",
              "info": "#3abff8",
              "success": "#36d399",
              "warning": "#fbbd23",
              "error": "#f87272",
              "--rounded-box": "1rem",
              "--rounded-btn": "0.8rem",
              "--rounded-badge": "1.9rem",
              "--animation-btn": "0.25s",
              "--animation-input": "0.2s",
              "--btn-focus-scale": "0.95",
              "--border-btn": "1px",
              "--tab-border": "1px",
              "--tab-radius": "0.5rem",
            },
            cyan: {
              "primary": "#06b6d4",
              "secondary": "#22d3ee",
              "accent": "#0891b2",
              "neutral": "#1f2937",
              "base-100": "#ffffff",
              "base-200": "#ecfeff",
              "base-300": "#cffafe",
              "info": "#3abff8",
              "success": "#36d399",
              "warning": "#fbbd23",
              "error": "#f87272",
              "--rounded-box": "1rem",
              "--rounded-btn": "0.8rem",
              "--rounded-badge": "1.9rem",
              "--animation-btn": "0.25s",
              "--animation-input": "0.2s",
              "--btn-focus-scale": "0.95",
              "--border-btn": "1px",
              "--tab-border": "1px",
              "--tab-radius": "0.5rem",
            },
          },
        ],
      },
    }
  </script>

  <!-- Libraries removed (duplicates) -->

  <style>
    /* Global Styles & Animations */
    .animate-bounce-slow { animation: bounce 3s infinite; }
    .animate-slide-up { animation: slideUp 0.3s cubic-bezier(0.16, 1, 0.3, 1); }
    @keyframes bounce {
      0%, 100% { transform: translateY(-5%); animation-timing-function: cubic-bezier(0.8, 0, 1, 1); }
      50% { transform: translateY(0); animation-timing-function: cubic-bezier(0, 0, 0.2, 1); }
    }
    @keyframes slideUp {
      from { transform: translateY(100%); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }
    .scrollbar-hide::-webkit-scrollbar { display: none; }
    .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
  </style>
</head>
<body class="bg-base-200/50 min-h-screen">
  <div id="app">
    <router-view></router-view>
  </div>

  <!-- TEMPLATE: Login -->
  <script type="text/x-template" id="login-template">
    <div class="min-h-screen flex flex-col items-center justify-center bg-base-100 p-6 relative overflow-hidden">
        <!-- Decorative blobs -->
        <div class="absolute top-[-10%] right-[-10%] w-64 h-64 bg-primary/20 rounded-full blur-3xl"></div>
        <div class="absolute bottom-[-10%] left-[-10%] w-64 h-64 bg-secondary/20 rounded-full blur-3xl"></div>
    
        <div class="w-full max-w-sm z-10">
          <div class="text-center mb-10">
            <div class="inline-flex items-center justify-center w-20 h-20 rounded-3xl bg-gradient-to-tr from-primary to-accent shadow-lg shadow-primary/30 text-4xl mb-6">
              üí™
            </div>
            <h1 class="text-4xl font-black text-base-content mb-2 tracking-tight">FitTrack</h1>
            <p class="text-base-content/60 font-medium">Ê¨¢ËøéÂõûÊù•ÔºåËøêÂä®ÂÅ•Â∞ÜÔºÅ</p>
          </div>
          
          <div class="space-y-4">
            <div class="form-control w-full">
              <input 
                type="text" 
                v-model="username" 
                placeholder="Áî®Êà∑Âêç" 
                class="input input-lg input-bordered w-full bg-base-200/50 border-none focus:ring-2 focus:ring-primary/50 focus:bg-base-100 transition-all rounded-2xl font-medium placeholder:text-base-content/30" 
              />
            </div>
            
            <div class="form-control w-full">
              <input 
                type="password" 
                v-model="password" 
                placeholder="ÂØÜÁ†Å" 
                class="input input-lg input-bordered w-full bg-base-200/50 border-none focus:ring-2 focus:ring-primary/50 focus:bg-base-100 transition-all rounded-2xl font-medium placeholder:text-base-content/30" 
                @keyup.enter="handleLogin" 
              />
            </div>
            
            <button 
              class="btn btn-primary btn-lg w-full rounded-2xl font-bold shadow-xl shadow-primary/30 mt-4 h-14" 
              @click="handleLogin" 
              :disabled="loading"
            >
              <span v-if="loading" class="loading loading-spinner"></span>
              {{ loading ? 'ÁôªÂΩï‰∏≠...' : 'ÁôªÂΩï' }}
            </button>
          </div>
        </div>

        <!-- Toast Notification -->
        <div v-if="error" class="toast toast-top toast-center z-50">
            <div class="alert alert-error text-white shadow-lg rounded-2xl">
                <svg xmlns="http://www.w3.org/2000/svg" class="stroke-current shrink-0 h-6 w-6" fill="none" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 14l2-2m0 0l2-2m-2 2l-2-2m2 2l2 2m7-2a9 9 0 11-18 0 9 9 0 0118 0z" /></svg>
                <span>{{ error }}</span>
            </div>
        </div>
      </div>
  </script>

  <!-- TEMPLATE: Dashboard -->
  <script type="text/x-template" id="dashboard-template">
    <div class="min-h-screen bg-base-200/50 pb-24 font-sans flex flex-col h-screen overflow-hidden">
        
        <!-- MAIN CONTENT AREA -->
        <div class="flex-1 overflow-y-auto pb-24">
            <!-- TODAY TAB -->
            <div v-if="activeTab === 'today'" class="animate-fade-in">
                <!-- Header -->
                <header class="pt-8 px-6 pb-6 bg-base-100 rounded-b-[2.5rem] shadow-sm mb-6">
                   <div class="flex justify-between items-center mb-6">
                     <div>
                       <p class="text-sm text-base-content/60 font-medium">‰Ω†Â•ΩÔºå</p>
                       <h1 class="text-2xl font-black text-base-content">{{ authStore.userConfig?.nickname || authStore.userConfig?.username || 'Athlete' }}</h1>
                     </div>
                     <div class="dropdown dropdown-end">
                        <div tabindex="0" role="button" class="btn btn-circle btn-ghost bg-base-200 hover:bg-base-300 border-none shadow-sm">
                           <span class="text-xl font-bold text-primary">{{ userInitial }}</span>
                        </div>
                        <ul tabindex="0" class="menu menu-sm dropdown-content mt-3 z-[1] p-2 shadow-xl bg-base-100 rounded-2xl w-40 border border-base-200">
                          <li>
                            <details open>
                              <summary class="font-medium">‰∏ªÈ¢òËâ≤</summary>
                              <ul class="p-2 bg-base-100 rounded-t-none flex flex-wrap gap-1">
                                <li v-for="theme in themes" :key="theme.name" class="w-full">
                                    <a @click="setTheme(theme.value)" class="flex justify-between items-center" :class="{'active': currentTheme === theme.value}">
                                        <span>{{ theme.name }}</span>
                                        <span class="w-3 h-3 rounded-full" :style="{ backgroundColor: theme.color }"></span>
                                    </a>
                                </li>
                              </ul>
                            </details>
                          </li>
                          <div class="divider my-0"></div>
                          <li><a @click="logout" class="text-error font-medium">ÈÄÄÂá∫ÁôªÂΩï</a></li>
                        </ul>
                     </div>
                   </div>
            
                   <!-- Main Stats Card -->
                   <div class="bg-primary text-primary-content rounded-[2rem] p-6 shadow-xl shadow-primary/30 relative overflow-hidden">
                     <!-- Background Patterns -->
                     <div class="absolute top-0 right-0 -mt-8 -mr-8 w-32 h-32 bg-white/10 rounded-full blur-2xl"></div>
                     <div class="absolute bottom-0 left-0 -mb-8 -ml-8 w-32 h-32 bg-black/10 rounded-full blur-2xl"></div>
                     
                     <div class="flex justify-between items-end relative z-10">
                        <div>
                            <div class="text-primary-content/80 text-sm font-medium mb-1">‰ªäÊó•Ê∂àËÄó</div>
                            <div class="text-5xl font-black tracking-tight">{{ todayKcal }}</div>
                            <div class="text-primary-content/60 text-xs mt-2 font-medium">Âç°Ë∑ØÈáå</div>
                        </div>
                        <div class="text-right">
                            <div class="text-3xl font-bold">{{ todaySets }}</div>
                            <div class="text-primary-content/80 text-xs font-medium uppercase tracking-wide">ËøêÂä®ÁªÑÊï∞</div>
                        </div>
                     </div>
                   </div>
                </header>
            
                <!-- Quick Actions -->
                <div class="px-6 mb-8">
                   <div class="flex items-center justify-between mb-4">
                     <h3 class="font-bold text-lg text-base-content/90">Âø´ÈÄüËÆ∞ÂΩï</h3>
                     <button @click="fetchActions(true)" class="btn btn-ghost btn-xs text-primary" :class="{'loading': actionsLoading}">
                        <span v-if="!actionsLoading">‚Üª</span>
                     </button>
                   </div>
                   
                   <!-- Category Tabs -->
                   <div class="flex gap-2 overflow-x-auto pb-2 mb-2 scrollbar-hide">
                       <button 
                           v-for="cat in categories" 
                           :key="cat"
                           @click="activeCategory = cat"
                           class="btn btn-sm rounded-full transition-all border-none flex-shrink-0"
                           :class="activeCategory === cat ? 'bg-primary text-primary-content shadow-md shadow-primary/30' : 'bg-base-200 text-base-content/60'"
                       >
                           {{ cat }}
                       </button>
                   </div>

                   <div v-if="actionsLoading && allActions.length === 0" class="flex justify-center py-8">
                       <span class="loading loading-spinner text-primary"></span>
                   </div>

                   <div v-else class="grid grid-cols-4 gap-3">
                      <button 
                         v-for="action in filteredPreferredActions" 
                         :key="action.id"
                         @click="openModal(action)"
                         class="flex flex-col items-center justify-center p-2 rounded-2xl bg-base-100 border border-base-200 shadow-sm active:scale-95 transition-all h-28 relative group"
                      >
                         <div class="w-10 h-10 rounded-full flex items-center justify-center text-xl mb-1" :class="action.color">
                             {{ action.icon }}
                         </div>
                         <div class="text-[10px] font-bold text-center leading-tight text-base-content/80 line-clamp-2">{{ action.label }}</div>
                      </button>

                      <!-- Add Button (Weak) -->
                      <button 
                          @click="openPreferenceModal"
                          class="flex flex-col items-center justify-center p-2 rounded-2xl border-2 border-dashed border-base-300 text-base-content/30 hover:border-primary/50 hover:text-primary transition-all h-28"
                      >
                          <div class="w-10 h-10 rounded-full bg-base-200 flex items-center justify-center text-xl mb-1">+</div>
                          <div class="text-[10px] font-bold">Ê∑ªÂä†</div>
                      </button>
                   </div>
                </div>

                <!-- Today's List -->
                <div class="px-6 pb-20">
                   <h3 class="font-bold text-lg text-base-content/90 mb-4">‰ªäÊó•ËÆ∞ÂΩï</h3>
                   <div class="relative border-l-2 border-base-300 space-y-8">
                      <!-- Loading Skeleton -->
                      <div v-if="initLoading" class="pl-6 space-y-4">
                          <div class="h-20 bg-base-100 rounded-2xl animate-pulse"></div>
                          <div class="h-20 bg-base-100 rounded-2xl animate-pulse opacity-60"></div>
                          <div class="h-20 bg-base-100 rounded-2xl animate-pulse opacity-30"></div>
                      </div>

                      <!-- Empty State -->
                      <div v-else-if="history.length === 0" class="pl-6 py-8 text-center text-base-content/40 italic">
                         ÊöÇÊó†ËøêÂä®ËÆ∞ÂΩïÔºåÂø´ÂéªÂä®Ëµ∑Êù•ÂêßÔºÅ
                      </div>
                      
                      <!-- List -->
                      <div 
                         v-else
                         v-for="(record, index) in history" 
                         :key="record.id"
                         class="relative pl-6 group"
                      >
                         <!-- Timeline Dot -->
                         <div class="absolute -left-[7px] top-6 w-4 h-4 rounded-full border-2 border-base-100" :class="index === 0 ? 'bg-primary ring-4 ring-primary/20' : 'bg-base-300'"></div>
                         
                         <!-- Content -->
                         <!-- Wrapper for Swipe -->
                         <div class="relative overflow-hidden rounded-2xl">
                             <!-- Delete Action Background -->
                             <div 
                                 class="absolute inset-y-0 right-0 w-20 bg-error/10 text-error flex flex-col items-center justify-center cursor-pointer active:bg-error/20 transition-colors"
                                 @click.stop="deleteRecord(record.id)"
                             >
                                 <span v-if="deletingId === record.id" class="loading loading-spinner loading-xs"></span>
                                 <template v-else>
                                     <span class="text-lg">üóëÔ∏è</span>
                                 </template>
                             </div>

                             <!-- Swipeable Content Card -->
                             <div 
                                 class="bg-base-100 p-4 shadow-sm border border-base-100 flex justify-between items-center relative z-10 select-none touch-pan-y"
                                 :style="getSwipeStyle(record.id)"
                                 @touchstart.passive="onSwipeStart($event, record.id)"
                                 @touchmove="onSwipeMove"
                                 @touchend="onSwipeEnd"
                                 @mousedown="onSwipeStart($event, record.id)"
                                 @mousemove="onSwipeMove"
                                 @mouseup="onSwipeEnd"
                                 @mouseleave="onSwipeEnd"
                             >
                                <div class="flex items-center gap-3 pointer-events-none">
                                   <div class="w-10 h-10 rounded-xl bg-base-200 flex items-center justify-center text-xl">
                                      {{ getIcon(record.actionType) }}
                                   </div>
                                   <div>
                                      <div class="font-bold text-base-content">{{ record.actionType }}</div>
                                      <div class="text-xs text-base-content/50 font-medium">{{ formatTime(record.date) }}</div>
                                   </div>
                                </div>
                                
                                <div class="text-right pointer-events-none">
                                   <div class="font-black text-lg text-base-content">{{ record.count }} <span class="text-xs font-medium text-base-content/40">Ê¨°</span></div>
                                   <div class="text-xs font-bold text-primary">{{ record.kcal }} kcal</div>
                                </div>
                             </div>
                         </div>
                      </div>
                   </div>
                </div>
            </div>

            <!-- HISTORY TAB -->
            <div v-else-if="activeTab === 'history'" class="animate-fade-in px-6 pt-8">
                <h1 class="text-3xl font-black text-base-content mb-8">ÂéÜÂè≤ËÆ∞ÂΩï</h1>
                
                <div v-if="historyLoading" class="flex justify-center py-20">
                    <span class="loading loading-spinner loading-lg text-primary"></span>
                </div>

                <div v-else>
                    <!-- History Heatmap View -->
                    <div class="bg-base-100 p-4 rounded-3xl shadow-sm border border-base-100 overflow-hidden mb-6" style="overflow: visible !important;">
                        <div class="overflow-x-auto pb-2 scrollbar-hide" style="direction: rtl; overflow: visible !important;">
                            <!-- Grid Container (Reversed direction for RTL to start from right) -->
                            <div class="grid grid-rows-7 grid-flow-col gap-1 w-max ltr" style="direction: ltr;">
                               <div 
                                  v-for="(day, index) in heatmapData" 
                                  :key="index"
                                  class="w-3 h-3 rounded-[2px] transition-colors hover:ring-2 ring-primary/50 relative group cursor-pointer"
                                  :class="[day.color, {'invisible': day.invisible}]"
                               >
                                  <!-- Tooltip -->
                                  <div v-if="!day.invisible" class="absolute bottom-full left-1/2 -translate-x-1/2 mb-2 px-2 py-1 bg-gray-800 text-white text-xs rounded opacity-0 group-hover:opacity-100 pointer-events-none whitespace-nowrap z-10 transition-opacity">
                                      {{ day.date }}: {{ day.count }} ÁªÑ
                                  </div>
                               </div>
                            </div>
                        </div>
                        
                        <!-- Legend -->
                        <div class="flex items-center justify-end gap-2 mt-4 text-xs text-base-content/40">
                            <span>Â∞ë</span>
                            <div class="w-3 h-3 rounded-[2px] bg-base-200"></div>
                            <div class="w-3 h-3 rounded-[2px] bg-green-200"></div>
                            <div class="w-3 h-3 rounded-[2px] bg-green-400"></div>
                            <div class="w-3 h-3 rounded-[2px] bg-green-600"></div>
                            <span>Â§ö</span>
                        </div>
                    </div>

                    <!-- Stats Card -->
                    <div class="p-5 bg-gradient-to-br from-base-100 to-base-200 rounded-3xl border border-base-100 shadow-sm mb-6">
                        <div class="flex items-center gap-3 mb-2">
                            <div class="w-8 h-8 rounded-full bg-primary/10 flex items-center justify-center text-primary">üìä</div>
                            <h4 class="font-bold text-base-content/80">Êú¨ÊúàÁªüËÆ°</h4>
                        </div>
                        <p class="text-base-content font-medium leading-relaxed">
                            {{ historyStatsText }}
                        </p>
                    </div>
                </div>
            </div>

            <!-- PUMP TAB -->
            <div v-else-if="activeTab === 'pump'" class="h-full relative flex flex-col items-center justify-center overflow-hidden bg-base-100 animate-fade-in" style="background-color: inherit;">
                <!-- Swipeable Cards Container -->
                <div class="relative w-full max-w-md h-[65vh] flex items-center justify-center perspective-1000">
                    
                    <div v-if="pumpLoading" class="loading loading-spinner loading-lg text-primary"></div>
                    
                    <div v-else-if="pumpData.length === 0" class="text-center p-8">
                        <h2 class="text-2xl font-bold mb-2">ÊöÇÊó†Êï∞ÊçÆ</h2>
                        <button @click="fetchPumpData" class="btn btn-primary btn-sm">ÈáçËØï</button>
                    </div>

                    <div 
                        v-else
                        class="absolute w-full h-full p-4"
                        :style="cardStyle"
                        @touchstart="onCardTouchStart"
                        @touchmove="onCardTouchMove"
                        @touchend="onCardTouchEnd"
                        @mousedown="onCardTouchStart"
                        @mousemove="onCardTouchMove"
                        @mouseup="onCardTouchEnd"
                        @mouseleave="onCardTouchEnd"
                    >
                        <!-- Card -->
                        <div class="w-full h-full bg-white rounded-[2rem] shadow-2xl border border-base-200 flex flex-col overflow-hidden relative select-none cursor-grab active:cursor-grabbing">
                            <!-- Cover Image -->
                            <div v-if="currentCard.cover" class="h-1/2 w-full bg-gray-100 overflow-hidden relative">
                                <img :src="currentCard.cover" class="w-full h-full object-cover pointer-events-none" alt="Cover">
                                <div class="absolute inset-0 bg-gradient-to-t from-black/60 via-transparent to-transparent"></div>
                                <div class="absolute bottom-4 left-4 right-4">
                                     <span class="inline-block px-3 py-1 bg-primary/90 text-primary-content text-xs font-bold rounded-full backdrop-blur-sm mb-1">
                                        {{ currentCard.category }}
                                     </span>
                                </div>
                            </div>
                            <!-- No Cover State -->
                            <div v-else class="h-1/3 w-full bg-gradient-to-br from-base-200 to-base-100 flex items-center justify-center relative">
                                <div class="absolute bottom-4 left-4">
                                     <span class="inline-block px-3 py-1 bg-base-300 text-base-content/60 text-xs font-bold rounded-full mb-1">
                                        {{ currentCard.category }}
                                     </span>
                                </div>
                            </div>

                            <!-- Content -->
                            <div class="flex-1 p-8 flex flex-col justify-center text-center relative">
                                <h3 
                                    class="font-normal text-base-content mb-6 leading-tight"
                                    :class="titleClass"
                                >
                                    {{ currentCard.title }}
                                </h3>
                                <p class="text-base-content/60 font-medium leading-relaxed text-lg line-clamp-4">{{ currentCard.content }}</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Footer Text -->
                <div class="absolute bottom-24 text-center w-full px-6 opacity-40">
                    <p class="text-xs font-medium">Ê∞ÆÊ≥µÈáèÊúâÈôêÔºåÂäüËÉΩÊµãËØï‰∏≠ÔºåÊï¨ËØ∑ÊúüÂæÖ~</p>
                </div>
            </div>
        </div>

        <div v-if="activeTab === 'today'" class="fixed bottom-24 right-6 z-40">
            <div 
                class="relative flex items-center justify-center w-16 h-16 bg-primary text-primary-content rounded-full shadow-lg cursor-pointer transition-transform active:scale-95 select-none touch-none"
                @touchstart.prevent="startListening"
                @touchend.prevent="stopListening"
                @touchcancel.prevent="stopListening"
                @touchmove.prevent
                @mousedown.prevent="startListening"
                @mouseup.prevent="stopListening"
                @mouseleave="stopListening"
                @contextmenu.prevent
            >
                <!-- Ripple Effect -->
                <div v-if="isListening" class="absolute inset-0 rounded-full bg-primary animate-ping opacity-75"></div>
                <div v-if="isListening" class="absolute inset-[-8px] rounded-full border-2 border-primary opacity-40 animate-pulse"></div>
                
                <!-- Icon -->
                <span class="text-2xl relative z-10">{{ isListening ? 'üéôÔ∏è' : 'üé§' }}</span>
                
                <!-- Listening Hint -->
                <div v-if="isListening" class="absolute bottom-full mb-4 right-0 bg-neutral text-neutral-content text-xs px-3 py-1.5 rounded-lg whitespace-nowrap backdrop-blur-md font-bold shadow-xl animate-bounce">
                    {{ voiceTranscript || 'Ê≠£Âú®Âê¨...' }}
                </div>
            </div>
        </div>

        <!-- BOTTOM NAVIGATION -->
        <div class="btm-nav btm-nav-lg bg-base-100/90 backdrop-blur-md border-t border-base-200 z-40 rounded-t-3xl shadow-[0_-5px_20px_-5px_rgba(0,0,0,0.1)]">
            <button 
                :class="activeTab === 'today' ? 'active text-primary bg-primary/10' : 'text-base-content/40 hover:text-base-content/60'"
                @click="activeTab = 'today'"
            >
                <span class="text-xl mb-1">üìÖ</span>
                <span class="btm-nav-label text-xs font-bold">‰ªäÊó•</span>
            </button>
            <button 
                :class="activeTab === 'history' ? 'active text-primary bg-primary/10' : 'text-base-content/40 hover:text-base-content/60'"
                @click="switchTab('history')"
            >
                <span class="text-xl mb-1">üìä</span>
                <span class="btm-nav-label text-xs font-bold">ÂéÜÂè≤</span>
            </button>
            <button 
                :class="activeTab === 'pump' ? 'active text-primary bg-primary/10' : 'text-base-content/40 hover:text-base-content/60'"
                @click="switchTab('pump')"
            >
                <span class="text-xl mb-1">‚ö°Ô∏è</span>
                <span class="btm-nav-label text-xs font-bold">Ê∞ÆÊ≥µ</span>
            </button>
        </div>

        <number-selector-modal 
          :is-open="isModalOpen" 
          :title="currentAction.label" 
          :description="currentAction.description"
          :kcal-per-rep="currentAction.kcal" 
          :loading="loading"
          :action="currentAction"
          :user-weight="authStore.userConfig?.weight"
          :initial-count="initialModalCount"
          :initial-weight="initialModalWeight"
          :auto-submit="isModalAutoSubmit"
          @close="closeModal" 
          @confirm="handleConfirm" 
        ></number-selector-modal>

        <preference-selector-modal
          :is-open="isPreferenceModalOpen"
          :category="activeCategory"
          :actions="currentCategoryActions"
          :initial-selected="initialModalSelected"
          :loading="preferenceSaving"
          @close="closePreferenceModal"
          @save="savePreferences"
        ></preference-selector-modal>

        <rest-timer-modal 
          :is-open="isRestTimerOpen" 
          :loading="repeatLoading"
          :show-success="repeatSuccess"
          @close="isRestTimerOpen = false"
          @repeat="handleRepeat"
        ></rest-timer-modal>

        <height-weight-modal
            :is-open="isHWModalOpen"
            :loading="hwLoading"
            @save="saveUserInfo"
        ></height-weight-modal>
    </div>
  </script>

  <!-- TEMPLATE: Modal -->
  <script type="text/x-template" id="modal-template">
    <div v-if="isOpen" class="fixed inset-0 z-50 flex items-end justify-center sm:items-center">
        <!-- Backdrop -->
        <div class="absolute inset-0 bg-black/60 backdrop-blur-sm transition-opacity" @click="close"></div>
        
        <!-- Modal Content -->
        <div class="relative w-full max-w-lg bg-base-100 rounded-t-[2.5rem] sm:rounded-[2.5rem] p-6 shadow-2xl transform transition-transform animate-slide-up overflow-hidden">
          <!-- Drag Handle -->
          <div class="w-12 h-1.5 bg-base-300 rounded-full mx-auto mb-6 opacity-50"></div>
          
          <div class="text-center mb-8">
             <h3 class="text-2xl font-black text-base-content mb-1">{{ title }}</h3>
             <p v-if="description" class="text-sm text-base-content/60 font-medium mb-2 px-8 leading-relaxed">{{ description }}</p>
             <div class="inline-flex items-center gap-1.5 px-3 py-1 bg-primary/10 text-primary rounded-full text-xs font-bold uppercase tracking-wide mt-1">
                <span>üî•</span>
                <span>{{ (estimatedKcal / count).toFixed(2) }} ÂçÉÂç° / Ê¨°</span>
             </div>
          </div>
          
          <!-- Main Counter -->
          <div class="flex items-center justify-between gap-4 mb-6 px-4">
              <button 
                class="btn btn-circle btn-xl bg-base-200 hover:bg-base-300 border-none text-2xl h-16 w-16 shadow-inner active:scale-95 transition-transform"
                @click="decrement"
              >
                <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 opacity-60" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M20 12H4" /></svg>
              </button>
              
              <div class="flex flex-col items-center">
                 <input 
                    type="number" 
                    :value="count" 
                    @input="e => updateCount(e.target.value)"
                    class="text-7xl font-black text-center w-40 bg-transparent border-none focus:ring-0 p-0 tabular-nums tracking-tighter"
                 />
                 <span class="text-sm font-bold text-base-content/40 uppercase tracking-widest mt-[-5px]">Ê¨°</span>
              </div>
              
              <button 
                class="btn btn-circle btn-xl bg-base-200 hover:bg-base-300 border-none text-2xl h-16 w-16 shadow-inner active:scale-95 transition-transform"
                @click="increment"
              >
                <svg xmlns="http://www.w3.org/2000/svg" class="h-8 w-8 opacity-60" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="3" d="M12 6v6m0 0v6m0-6h6m-6 0H6" /></svg>
              </button>
          </div>
          
          <!-- Count Presets -->
          <div class="flex justify-between gap-2 mb-6 overflow-x-auto pb-2 px-1 scrollbar-hide">
             <button 
                v-for="preset in presets" 
                :key="preset"
                @click="selectPreset(preset)"
                class="btn btn-md rounded-2xl flex-1 font-bold border-none transition-all"
                :class="count === preset ? 'bg-primary text-primary-content shadow-lg shadow-primary/30' : 'bg-base-200 text-base-content/60 hover:bg-base-300'"
             >
                {{ preset }}
             </button>
          </div>

          <!-- Weight Selector (Only for Weighted) -->
          <div v-if="isWeighted" class="mb-8 px-4">
              <div class="flex items-center justify-between mb-2">
                  <span class="text-xs font-bold text-base-content/40 uppercase tracking-widest">Ë¥üÈáç (KG)</span>
                  <span class="text-lg font-black text-base-content tabular-nums">{{ weightLifted }} <span class="text-xs">kg</span></span>
              </div>
              <input 
                  type="range" 
                  min="0" 
                  max="100" 
                  v-model.number="weightLifted" 
                  class="range range-xs range-primary w-full mb-3" 
              />
              <div class="flex justify-between gap-1 overflow-x-auto pb-2 scrollbar-hide">
                 <button 
                    v-for="wp in weightPresets" 
                    :key="wp"
                    @click="selectWeightPreset(wp)"
                    class="btn btn-xs rounded-lg font-bold border-none transition-all min-w-[2.5rem]"
                    :class="weightLifted === wp ? 'bg-secondary text-secondary-content' : 'bg-base-200 text-base-content/50 hover:bg-base-300'"
                 >
                    {{ wp }}
                 </button>
              </div>
          </div>
          
          <!-- Info & Actions -->
          <div class="bg-base-200/50 rounded-3xl p-4 mb-6 flex items-center justify-between">
              <div class="flex flex-col pl-2">
                 <span class="text-xs font-bold text-base-content/50 uppercase">È¢ÑËÆ°Ê∂àËÄó</span>
                 <span class="text-2xl font-black text-primary">{{ estimatedKcal }} <span class="text-sm text-base-content/40 font-medium">kcal</span></span>
              </div>
              <button 
                  class="btn btn-primary btn-lg rounded-2xl px-8 font-bold shadow-xl shadow-primary/20" 
                  @click="confirm"
                  :disabled="loading"
              >
                 <span v-if="loading" class="loading loading-spinner"></span>
                 <span v-else>‰øùÂ≠òËÆ∞ÂΩï</span>
              </button>
          </div>
          
          <!-- Auto Submit Toast -->
          <div v-if="autoSubmitCountdown > 0" class="absolute bottom-0 left-0 right-0 bg-base-100/95 p-6 border-t border-base-200 shadow-[0_-10px_40px_-10px_rgba(0,0,0,0.2)] z-20 flex items-center justify-between animate-slide-up pb-8">
              <div class="flex items-center gap-3">
                  <div class="radial-progress text-primary text-xs font-bold" :style="{'--value': (autoSubmitCountdown/5)*100, '--size': '2.5rem'}">{{ autoSubmitCountdown }}s</div>
                  <div class="flex flex-col">
                      <span class="font-bold text-base-content">Âç≥Â∞ÜËá™Âä®Êèê‰∫§</span>
                      <span class="text-xs text-base-content/60">Á°ÆËÆ§Êï∞ÊçÆÊó†ËØØ...</span>
                  </div>
              </div>
              <button class="btn btn-ghost btn-sm text-error font-bold bg-error/10 hover:bg-error/20" @click="cancelAutoSubmit">ÂèñÊ∂à</button>
          </div>
        </div>
      </div>
  </script>

  <!-- TEMPLATE: Rest Timer Modal -->
  <script type="text/x-template" id="rest-timer-template">
    <div v-if="isOpen" class="fixed inset-0 z-[60] flex items-center justify-center">
        <!-- Backdrop -->
        <div class="absolute inset-0 bg-black/80 backdrop-blur-sm transition-opacity"></div>
        
        <!-- Content -->
        <div class="relative w-full max-w-sm mx-6 bg-base-100 rounded-[2.5rem] p-8 shadow-2xl text-center overflow-hidden animate-slide-up">
            <!-- Decorative Background -->
            <div class="absolute top-0 left-0 w-full h-2 bg-gradient-to-r from-primary to-secondary"></div>
            
            <!-- Loading State -->
            <div v-if="loading" class="py-12 flex flex-col items-center justify-center animate-fade-in">
                 <span class="loading loading-spinner loading-lg text-primary mb-4"></span>
                 <p class="text-lg font-bold text-base-content/80">Ê≠£Âú®Êèê‰∫§...</p>
            </div>

            <!-- Success State -->
            <div v-else-if="showSuccess" class="py-12 flex flex-col items-center justify-center animate-fade-in">
                 <div class="w-20 h-20 bg-success/20 rounded-full flex items-center justify-center mb-4 text-4xl text-success animate-bounce">
                    ‚úì
                 </div>
                 <p class="text-xl font-black text-base-content">Â∑≤ËÆ∞ÂΩï!</p>
                 <p class="text-sm text-base-content/60">ÂáÜÂ§á‰∏ã‰∏ÄÁªÑ</p>
            </div>

            <!-- Timer State -->
            <div v-else class="animate-fade-in">
                <h3 class="text-2xl font-black text-base-content mb-2">‰ºëÊÅØ‰∏Ä‰∏ã</h3>
                <p class="text-base-content/60 font-medium mb-8">ÂáÜÂ§á‰∏ã‰∏ÄÁªÑËÆ≠ÁªÉ</p>
                
                <!-- Timer Circle -->
                <div class="relative w-48 h-48 mx-auto mb-8 flex items-center justify-center">
                    <svg class="w-full h-full -rotate-90 transform" viewBox="0 0 100 100">
                        <circle cx="50" cy="50" r="45" fill="none" stroke="currentColor" class="text-base-200" stroke-width="8" />
                        <circle cx="50" cy="50" r="45" fill="none" stroke="currentColor" class="text-primary transition-all duration-1000 ease-linear" stroke-width="8" :stroke-dasharray="283" :stroke-dashoffset="283 - (283 * timeLeft / totalTime)" stroke-linecap="round" />
                    </svg>
                    <div class="absolute inset-0 flex items-center justify-center flex-col">
                        <span class="text-6xl font-black tabular-nums tracking-tighter">{{ timeLeft }}</span>
                        <span class="text-xs font-bold text-base-content/40 uppercase tracking-widest mt-1">Áßí</span>
                    </div>
                </div>
                
                <button 
                    class="btn btn-primary btn-lg w-full rounded-2xl font-bold shadow-xl shadow-primary/30 mb-4" 
                    @click="$emit('repeat')"
                >
                    ÂÜçÊù•‰∏ÄÁªÑ
                </button>

                <button 
                    class="btn btn-ghost btn-lg w-full rounded-2xl font-bold text-base-content/60 hover:text-base-content hover:bg-base-200" 
                    @click="stop"
                >
                    ÂºÄÂßã‰∏ã‰∏ÄÁªÑ
                </button>
            </div>
        </div>
    </div>
  </script>

  <script type="module">
    import { pinyin } from 'https://esm.sh/pinyin-pro@3.19.6';
    import Levenshtein from 'https://esm.sh/fast-levenshtein@3.0.0';
    
    window.pinyin = pinyin;
    window.Levenshtein = Levenshtein;

    // ActionMatcher Class Definition
    class ActionMatcher {
        constructor(actions) {
            this.actions = actions.map(action => {
                const label = action.label || '';
                // Pre-calculate Pinyin (Full and Initials)
                const pinyinFull = pinyin(label, { toneType: 'none', type: 'array' }).join('').toLowerCase();
                const pinyinInitials = pinyin(label, { pattern: 'first', toneType: 'none', type: 'array' }).join('').toLowerCase();
                
                return {
                    ...action,
                    _pinyinFull: pinyinFull,
                    _pinyinInitials: pinyinInitials
                };
            });
        }

        search(input) {
            if (!input) return null;

            // Preprocess Input
            const inputFull = pinyin(input, { toneType: 'none', type: 'array' }).join('').toLowerCase();
            const inputInitials = pinyin(input, { pattern: 'first', toneType: 'none', type: 'array' }).join('').toLowerCase();

            let bestMatch = null;
            let maxScore = -1;

            for (const action of this.actions) {
                let score = 0;
                
                // Track A: Chinese Substring (Weight: 100)
                // "ÂÅö‰∏™ÂçßÊé®" (input contains label) OR "Âºï‰Ωì" (label contains input)
                if (input.includes(action.label) || action.label.includes(input)) {
                    score = 100;
                } else {
                    // Track B: Full Pinyin Similarity (Weight: 70%)
                    const distFull = window.Levenshtein.get(action._pinyinFull, inputFull);
                    const lenFull = Math.max(action._pinyinFull.length, inputFull.length);
                    const simFull = lenFull === 0 ? 0 : 1 - (distFull / lenFull);

                    // Track C: Initials Similarity (Weight: 30%)
                    const distInit = window.Levenshtein.get(action._pinyinInitials, inputInitials);
                    const lenInit = Math.max(action._pinyinInitials.length, inputInitials.length);
                    const simInit = lenInit === 0 ? 0 : 1 - (distInit / lenInit);

                    // Combined Score
                    score = (simFull * 0.7 + simInit * 0.3) * 100;

                    // Bonus: Full Pinyin Substring Match (Reward: 40)
                    if (action._pinyinFull.includes(inputFull) || inputFull.includes(action._pinyinFull)) {
                         score += 40;
                    }
                }

                if (score > maxScore) {
                    maxScore = score;
                    bestMatch = action;
                }
            }
            
            // Threshold: Let's say 40? Or just return best.
            // If score is too low, maybe it's noise. But user didn't specify threshold.
            return bestMatch; 
        }
    }

    window.ActionMatcher = ActionMatcher;

    // Utility: Chinese Number to Arabic Number
    const chnNumChar = {
        'Èõ∂':0, '‰∏Ä':1, '‰∫å':2, '‰∏§':2, '‰∏â':3, 'Âõõ':4, '‰∫î':5, 'ÂÖ≠':6, '‰∏É':7, 'ÂÖ´':8, '‰πù':9
    };
    const chnNameValue = {
        'ÂçÅ':10, 'Áôæ':100, 'ÂçÉ':1000
    };

    function chineseToNumber(text) {
        // Replace mixed Chinese numbers in text with Arabic numbers
        // e.g. "‰∏ÄÁôæ‰∫åÂçÅ" -> "120", "‰∫åÂçÅ‰∫î" -> "25", "‰∏â" -> "3"
        // This is a simple regex-based replacement loop for identifying number chunks
        
        // Regex to find Chinese number patterns
        const pattern = /[Èõ∂‰∏Ä‰∫å‰∏§‰∏âÂõõ‰∫îÂÖ≠‰∏ÉÂÖ´‰πùÂçÅÁôæÂçÉ]+/g;
        
        return text.replace(pattern, (match) => {
             let rtn = 0;
             let section = 0;
             let number = 0;
             let secUnit = false;
             const str = match.toString();
             
             // Simple parsing logic
             let val = 0;
             let i = 0;
             
             // Special case: "ÂçÅ" at start (e.g., ÂçÅ‰∫å -> 12, ÂçÅ -> 10)
             if (str.length > 0 && str[0] === 'ÂçÅ') {
                 if (str.length === 1) return '10';
                 // "ÂçÅ‰∫å" -> 1*10 + 2
                 // Let standard loop handle it but treat initial 'ÂçÅ' as 10
             }

             // Standard loop for < 10000
             // e.g. ‰∏ÄÁôæ‰∫åÂçÅ‰∫î
             let tempVal = 0;
             let lastUnit = 1;
             
             // Convert string to array of values/units
             const tokens = [];
             for(let char of str) {
                 if (chnNumChar[char] !== undefined) {
                     tokens.push({t:'num', v:chnNumChar[char]});
                 } else if (chnNameValue[char] !== undefined) {
                     tokens.push({t:'unit', v:chnNameValue[char]});
                 }
             }

             // Calculate
             let result = 0;
             let currentNum = 0;
             let hasNum = false;
             
             for (let j=0; j<tokens.length; j++) {
                 const token = tokens[j];
                 if (token.t === 'num') {
                     currentNum = token.v;
                     hasNum = true;
                     // If it's the last digit, add it
                     if (j === tokens.length - 1) {
                         result += currentNum;
                     }
                 } else if (token.t === 'unit') {
                     if (!hasNum && token.v === 10) {
                         // Handling "ÂçÅ" at start or after zero? "ÂçÅ" usually implies 1*10 if no prev num
                         currentNum = 1;
                     }
                     result += currentNum * token.v;
                     currentNum = 0;
                     hasNum = false;
                 }
             }
             
             return result.toString();
        });
    }

    window.chineseToNumber = chineseToNumber;
  </script>

  <script>
    // Register Service Worker for PWA
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => {
        navigator.serviceWorker.register('./service-worker.js')
          .then(registration => {
            console.log('SW registered:', registration);
          })
          .catch(error => {
            console.log('SW registration failed:', error);
          });
      });
    }

    const { createApp, ref, computed, watch, onMounted, onUnmounted, defineComponent, toRef } = Vue; // Added toRef
    const { createRouter, createWebHashHistory, useRouter } = VueRouter;
    const { defineStore, createPinia } = Pinia;

    // --- Store ---
    const useAuthStore = defineStore('auth', () => {
      let storedConfig = null;
      try {
        storedConfig = JSON.parse(localStorage.getItem('userConfig'));
      } catch (e) {
        console.warn('Invalid userConfig in localStorage, resetting.');
        localStorage.removeItem('userConfig');
      }
      const userConfig = ref(storedConfig);
      
      function login(config) {
        userConfig.value = config;
        localStorage.setItem('userConfig', JSON.stringify(config));
      }

      function logout() {
        userConfig.value = null;
        localStorage.removeItem('userConfig');
        localStorage.removeItem('cachedActions');
        window.location.hash = '#/login'; 
      }
      
      // Update config (e.g., after fetching new weight)
      function updateConfig(newConfig) {
          userConfig.value = { ...userConfig.value, ...newConfig };
          localStorage.setItem('userConfig', JSON.stringify(userConfig.value));
      }

      return { userConfig, login, logout, updateConfig };
    });

    // --- Components ---

    // NumberSelectorModal
    const NumberSelectorModal = defineComponent({
      template: '#modal-template',
      props: ['isOpen', 'title', 'description', 'kcalPerRep', 'loading', 'action', 'userWeight', 'initialCount', 'initialWeight', 'autoSubmit'], 
      emits: ['close', 'confirm'],
      setup(props, { emit }) {
        const count = ref(10);
        const presets = [10, 20, 30, 40, 50];
        
        // Weight Lifted Logic
        const weightLifted = ref(10); // Default 10kg
        const weightPresets = [5, 10, 15, 20, 30, 40, 50];

        // Auto Submit Logic
        const autoSubmitCountdown = ref(0);
        let autoSubmitTimer = null;

        const cancelAutoSubmit = () => {
            if (autoSubmitTimer) {
                clearInterval(autoSubmitTimer);
                autoSubmitTimer = null;
            }
            autoSubmitCountdown.value = 0;
        };
        
        const isWeighted = computed(() => {
             return props.action && props.action.calc_mode && props.action.calc_mode.toLowerCase() === 'weighted';
        });

        watch(() => props.isOpen, (newVal) => {
          if (newVal) {
            cancelAutoSubmit(); // Clear any previous

            // Count Logic
            if (props.initialCount) {
                count.value = parseInt(props.initialCount);
            } else {
                count.value = 10;
            }

            // Weight Logic
            if (props.initialWeight) {
                weightLifted.value = parseFloat(props.initialWeight);
            } else if (props.action) {
                const savedWeight = localStorage.getItem(`weight_lifted_${props.action.id}`);
                if (savedWeight) {
                    weightLifted.value = parseInt(savedWeight);
                } else {
                    weightLifted.value = 10;
                }
            }

            // Auto Submit Start
            if (props.autoSubmit) {
                autoSubmitCountdown.value = 5;
                autoSubmitTimer = setInterval(() => {
                    autoSubmitCountdown.value--;
                    if (autoSubmitCountdown.value <= 0) {
                        cancelAutoSubmit(); // Stop timer
                        confirm(); // Trigger confirm
                    }
                }, 1000);
            }
          } else {
            cancelAutoSubmit();
          }
        });

        const estimatedKcal = computed(() => {
          // If action has no MET/seconds_per_rep, fallback to simple kcalPerRep
          // But if we have calc_mode='weighted', we should try to be dynamic even if some data is missing (using defaults)
          
          const met = props.action?.met || 3.0; // Default moderate intensity
          const seconds = props.action?.seconds_per_rep || 3.0;
          const weight = props.userWeight || 70; // Default 70kg if missing
          
          // If we really lack specific action data, use the static kcalPerRep as base, 
          // BUT if it's weighted, we must add the weight factor.
          
          let baseKcalPerRep;
          
          if (props.action && props.action.met && props.action.seconds_per_rep) {
               // Formula 1: Standard MET calculation
               baseKcalPerRep = met * weight * (seconds / 3600);
          } else {
               // Fallback to static value from DB
               baseKcalPerRep = props.kcalPerRep || 0.5;
          }
          
          let finalKcalPerRep = baseKcalPerRep;
          
          // Formula 2: Weighted
          // Apply weight factor if mode is weighted
          if (props.action && props.action.calc_mode && props.action.calc_mode.toLowerCase() === 'weighted') {
               finalKcalPerRep = finalKcalPerRep * (1 + (weightLifted.value / weight));
          }
          
          return (count.value * finalKcalPerRep).toFixed(1);
        });

        const increment = () => {
          cancelAutoSubmit();
          if (navigator.vibrate) navigator.vibrate(50);
          count.value++;
        };
        const decrement = () => {
          cancelAutoSubmit();
          if (navigator.vibrate) navigator.vibrate(50);
          if (count.value > 1) count.value--;
        };
        
        const updateCount = (val) => {
            cancelAutoSubmit();
            let num = parseInt(val);
            if (!isNaN(num) && num > 0) {
                count.value = num;
            }
        }

        const selectPreset = (val) => {
          cancelAutoSubmit();
          if (navigator.vibrate) navigator.vibrate(50);
          count.value = val;
        };
        
        const selectWeightPreset = (val) => {
            cancelAutoSubmit();
            if (navigator.vibrate) navigator.vibrate(50);
            weightLifted.value = val;
            // Save immediately? Or on confirm? User said "update local after setting"
            // Let's save on confirm to be sure, but maybe here too for UX?
            // "Updated to local after user sets it" - implies immediately or on save.
            // I'll stick to saving on confirm to avoid trash data if they cancel.
        };

        const confirm = () => {
          cancelAutoSubmit(); // Just in case
          if (navigator.vibrate) navigator.vibrate(50);
          
          // Save weight preference
          if (isWeighted.value && props.action) {
               localStorage.setItem(`weight_lifted_${props.action.id}`, weightLifted.value);
          }
          
          emit('confirm', count.value, estimatedKcal.value, isWeighted.value ? weightLifted.value : 0);
        };

        const close = () => {
          cancelAutoSubmit();
          if (!props.loading) { // Prevent closing while loading
            emit('close');
          }
        };
        
        const loading = computed(() => props.loading);

        return { count, presets, estimatedKcal, increment, decrement, updateCount, selectPreset, confirm, close, loading, 
                 isWeighted, weightLifted, weightPresets, selectWeightPreset,
                 autoSubmitCountdown, cancelAutoSubmit };
      }
    });

    // Rest Timer Modal
    const RestTimerModal = defineComponent({
      template: '#rest-timer-template',
      props: ['isOpen', 'loading', 'showSuccess'],
      emits: ['close', 'repeat'],
      setup(props, { emit }) {
        const totalTime = 60;
        const timeLeft = ref(totalTime);
        let timer = null;

        const startTimer = () => {
            if (timer) clearInterval(timer);
            timeLeft.value = totalTime;
            timer = setInterval(() => {
                if (timeLeft.value > 0) {
                    timeLeft.value--;
                } else {
                    if (navigator.vibrate) navigator.vibrate(50);
                    clearInterval(timer);
                    timer = null;
                }
            }, 1000);
        };

        const stopTimer = () => {
            if (timer) clearInterval(timer);
            timer = null;
        };

        watch(() => props.isOpen, (newVal) => {
            if (newVal) {
                startTimer();
            } else {
                stopTimer();
            }
        });

        // Restart timer after success message is hidden
        watch(() => props.showSuccess, (newVal, oldVal) => {
            if (oldVal && !newVal && props.isOpen) {
                startTimer();
            }
        });

        const stop = () => {
            stopTimer();
            emit('close');
        };

        onUnmounted(() => {
            stopTimer();
        });

        const loading = computed(() => props.loading);
        const showSuccess = computed(() => props.showSuccess);

        return { timeLeft, totalTime, stop, loading, showSuccess };
      }
    });

    // Preference Selector Modal
    const PreferenceSelectorModal = defineComponent({
      template: '#preference-selector-template',
      props: ['isOpen', 'category', 'actions', 'initialSelected', 'loading'],
      emits: ['close', 'save'],
      setup(props, { emit }) {
        const selectedIds = ref([]);

        watch(() => props.isOpen, (newVal) => {
            if (newVal) {
                selectedIds.value = [...props.initialSelected];
            }
        });

        const toggle = (id) => {
            if (navigator.vibrate) navigator.vibrate(50);
            const index = selectedIds.value.indexOf(id);
            if (index > -1) {
                selectedIds.value.splice(index, 1);
            } else {
                selectedIds.value.push(id);
            }
        };

        const isSelected = (id) => selectedIds.value.includes(id);

        const save = () => {
            emit('save', selectedIds.value);
        };

        const close = () => {
            if (!props.loading) {
                emit('close');
            }
        };

        return { toggle, isSelected, save, close };
      }
    });

    // HeightWeightModal
    const HeightWeightModal = defineComponent({
      template: '#hw-modal-template',
      props: ['isOpen', 'loading'],
      emits: ['save'],
      setup(props, { emit }) {
        const height = ref('');
        const weight = ref('');
        
        const isValid = computed(() => {
            return height.value > 50 && height.value < 300 && weight.value > 20 && weight.value < 300;
        });

        const save = () => {
            if (isValid.value) {
                emit('save', { height: height.value, weight: weight.value });
            }
        };

        return { height, weight, isValid, save };
      }
    });

    // Login
    const Login = defineComponent({
      template: '#login-template',
      setup() {
        const router = useRouter();
        const authStore = useAuthStore();
        
        const username = ref('');
        const password = ref('');
        const loading = ref(false);
        const error = ref('');

        const handleLogin = async () => {
          loading.value = true;
          error.value = '';
          
          try {
            const response = await axios.post('/api/login', {
              username: username.value,
              password: password.value,
            });
            
            if (response.data.success) {
              authStore.login(response.data.userConfig);
              router.push('/');
            }
          } catch (err) {
            error.value = err.response?.data?.error || 'Login failed';
            setTimeout(() => {
              error.value = '';
            }, 3000);
          } finally {
            loading.value = false;
          }
        };
        
        return { username, password, loading, error, handleLogin };
      }
    });

    // Dashboard
    const Dashboard = defineComponent({
      template: '#dashboard-template',
      components: { NumberSelectorModal, RestTimerModal, PreferenceSelectorModal, HeightWeightModal },
      setup() {
        const router = useRouter();
        const authStore = useAuthStore();
        const history = ref([]);
        const allHistory = ref([]);
        const historyLoading = ref(false); // New
        const activeTab = ref('today'); // 'today', 'history', 'pump'
        const isModalOpen = ref(false);
        const isRestTimerOpen = ref(false);
        const currentAction = ref({});
        const loading = ref(false);
        const initLoading = ref(true);
        const deletingId = ref(null);
        
        // Pump Data
        const pumpData = ref([]);
        const currentCardIndex = ref(0);
        const pumpLoading = ref(false);
        const cardX = ref(0);
        const cardY = ref(0);
        const cardRotation = ref(0);
        const isDragging = ref(false);
        const isAnimating = ref(false); // New
        const isResetting = ref(false); // New
        
        // Theme Logic
        const currentTheme = ref(localStorage.getItem('theme') || 'fittrack');
        const themes = [
            { name: 'ÈªòËÆ§Á¥´', value: 'fittrack', color: '#6366f1' },
            { name: 'Ê¥ªÂäõÁ∫¢', value: 'red', color: '#ef4444' },
            { name: 'ÊûÅÂ§úÈªë', value: 'black', color: '#1f2937' },
            { name: 'Ëá™ÁÑ∂Áªø', value: 'green', color: '#10b981' },
            { name: 'Â§©Á©∫Ëìù', value: 'blue', color: '#3b82f6' },
            { name: 'ÊöñÈò≥Ê©ô', value: 'orange', color: '#f97316' },
            { name: 'ÈùíËâ≤', value: 'cyan', color: '#06b6d4' }
        ];

        const setTheme = (theme) => {
            currentTheme.value = theme;
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
        };
        
        // Touch handling for general swipe (removed for tabs, but kept logic vars if needed)
        // const touchStartX = ref(0);
        // const touchEndX = ref(0);
        
        const allActions = ref([]);
        const actionsLoading = ref(false);

        // --- Voice Assistant ---
        const isListening = ref(false);
        const voiceTranscript = ref('');
        let recognition = null;
        let actionMatcher = null; // Instance of ActionMatcher
        let debounceTimer = null; // For voice debounce

        // Modal init props
        const initialModalCount = ref(null);
        const initialModalWeight = ref(null);
        const isModalAutoSubmit = ref(false);

        // Check browser support
        const isSpeechSupported = 'webkitSpeechRecognition' in window || 'SpeechRecognition' in window;

        const startListening = () => {
            if (!isSpeechSupported) {
                alert('ÊÇ®ÁöÑÊµèËßàÂô®‰∏çÊîØÊåÅËØ≠Èü≥ËØÜÂà´ÂäüËÉΩ');
                return;
            }
            
            // Vibration feedback
            if (navigator.vibrate) navigator.vibrate(50);
            
            const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
            recognition = new SpeechRecognition();
            recognition.lang = 'zh-CN';
            recognition.interimResults = true; // Enable interim results for realtime feedback
            recognition.maxAlternatives = 1;
            
            recognition.onstart = () => {
                isListening.value = true;
                voiceTranscript.value = '';
            };
            
            recognition.onend = () => {
                isListening.value = false;
                // Ensure final processing happens if not already (debouncer might have one pending)
                // But usually we process on result.
            };
            
            recognition.onresult = (event) => {
                const transcript = Array.from(event.results)
                    .map(result => result[0].transcript)
                    .join('');
                
                voiceTranscript.value = transcript;
            };
            
            recognition.onerror = (event) => {
                console.error('Speech recognition error', event.error);
                isListening.value = false;
            };
            
            recognition.start();
            
            // Auto stop after 20s
            setTimeout(() => {
                if (isListening.value) stopListening();
            }, 20000);
        };

        const stopListening = () => {
            if (recognition) {
                recognition.stop();
            }
            isListening.value = false;
            
            // Process only when user stops listening (releases button)
            if (voiceTranscript.value && voiceTranscript.value.trim().length > 0) {
                processVoiceCommand(voiceTranscript.value);
            }
        };

        const processVoiceCommand = (text) => {
            // 0. Normalize Numbers (Chinese -> Arabic)
            let normalized = text.toLowerCase();
            if (window.chineseToNumber) {
                normalized = window.chineseToNumber(normalized);
            }
            // Normalize units
            normalized = normalized.replace(/ÂçÉÂÖã/g, 'kg').replace(/ÂÖ¨Êñ§/g, 'kg').replace(/Êñ§/g, 'kg'); // Treat 'jin' as 'kg' for simplicity or add logic
            
            // 1. Extract Numbers (Count and Weight)
            let weight = null;
            let count = null;
            
            // Regex strategies
            // A. Explicit Weight: (num)kg or (weight|load)(num)
            // B. Explicit Count: (num)(reps|sets|units) or (do)(num)
            
            // Weight Regex: 
            // 1. "50kg"
            // 2. "Ë¥üÈáç50"
            const weightRegex = /(\d+(?:\.\d+)?)\s*(?:kg|k)|(?:Ë¥üÈáç|ÈáçÈáè|weight)\s*(\d+(?:\.\d+)?)/;
            const weightMatch = normalized.match(weightRegex);
            
            if (weightMatch) {
                weight = weightMatch[1] || weightMatch[2];
            }
            
            // Count Regex:
            // 1. "12‰∏™", "12Ê¨°", "12‰∏ã", "12ÁªÑ"
            // 2. "ÂÅö12"
            const countRegex = /(\d+)\s*(?:‰∏™|Ê¨°|‰∏ã|ÁªÑ|ÈÅç|rep|reps)|(?:ÂÅö|ÂÅö‰∫Ü)\s*(\d+)/;
            const countMatch = normalized.match(countRegex);
            
            if (countMatch) {
                count = countMatch[1] || countMatch[2];
            } 
            
            // Fallback: If we have numbers but missed specific units
            if (!count || !weight) {
                // Remove matched parts to see what's left
                let remaining = normalized;
                if (weightMatch) remaining = remaining.replace(weightMatch[0], '');
                if (countMatch) remaining = remaining.replace(countMatch[0], '');
                
                // Look for remaining numbers
                const fallbackRegex = /(\d+)/g;
                const matches = remaining.match(fallbackRegex);
                
                if (matches) {
                    matches.forEach(num => {
                        const val = parseFloat(num);
                        // Heuristic: 
                        // If we have weight but no count -> this is likely count (usually integer, small < 100)
                        // If we have count but no weight -> this is likely weight (could be larger)
                        // If we have neither -> 
                        //    - If val > 100, likely weight (unless it's cardio seconds, but we assume reps for now)
                        //    - If val <= 50, likely count? Hard to say. 
                        //    - Usually weight is mentioned before count in "50kg 10reps" or "bench 50kg 10"
                        
                        if (weight && !count) {
                            count = Math.floor(val);
                        } else if (!weight && count) {
                            weight = val;
                        } else if (!weight && !count) {
                             // First number found. Is it weight or count?
                             // Context matters. "Bench 50" -> usually weight. "Pullups 10" -> usually count.
                             // Let's assume: if < 30 it's count, >= 30 it's weight (risky but better than nothing)
                             // Or better: prioritize count if no explicit weight unit found?
                             // Most users say "10‰∏™" (count). If just "50", might be weight.
                             if (val < 30) count = Math.floor(val);
                             else weight = val;
                        } else {
                            // We have one of them, filling the other.
                            // If we have both, maybe ignore?
                        }
                    });
                }
            }
            
            // 2. Match Action (Using ActionMatcher)
            // Strip numbers and common units/punctuation to isolate the "action name" intent
            const actionText = normalized
                .replace(weightRegex, '') // Remove weight pattern
                .replace(countRegex, '') // Remove count pattern
                .replace(/\d+/g, '') // Remove any remaining digits
                .replace(/(kg|k|‰∏™|Ê¨°|‰∏ã|ÁªÑ|ÈÅç|rep|reps)/g, '') // Remove units
                .replace(/[.,?!„ÄÇÔºåÔºüÔºÅ]/g, '') // Remove punctuation
                .replace(/(Â∏ÆÊàë|ËÆ∞ÂΩï|ËÆ∞‰∏Ä‰∏ã|ÂÅö|‰∏ÄÁªÑ|‰∏Ä‰∏™|Ë¥üÈáç|ÈáçÈáè)/g, '') // Remove common stop words
                .trim();
            
            if (!actionText) return;

            // Use the Triple-Track Matcher
            if (!actionMatcher && window.ActionMatcher) {
                 // Fallback init if not ready
                 actionMatcher = new window.ActionMatcher(allActions.value);
            }

            let bestMatch = null;
            if (actionMatcher) {
                bestMatch = actionMatcher.search(actionText);
            }
            
            if (bestMatch) {
                // Found!
                initialModalCount.value = count;
                initialModalWeight.value = weight;
                isModalAutoSubmit.value = true;
                
                openModal(bestMatch);
            } else {
                // Not found - Maybe log it or show toast instead of alert for better UX during debounce
                // console.log(`No match for: ${actionText}`);
                // Since we are debouncing, maybe we shouldn't alert every time.
                // Only alert if we are sure? Or maybe just do nothing until match.
                // But user wants feedback.
                // Let's use the voice transcript hint area for feedback "Êú™ÂåπÈÖç"
            }
        };

        // --- Preference Logic ---
        const categories = ['ËÉå', 'ËÉ∏', 'ËÇ©', 'ËÖø', 'Ê†∏ÂøÉ', 'ÊâãËáÇ'];
        const activeCategory = ref('ËÉå');
        const preferredActions = ref([]); // List of action IDs
        const isPreferenceModalOpen = ref(false);
        const preferenceSaving = ref(false);

        // Height/Weight Modal Logic
        const isHWModalOpen = ref(false);
        const hwLoading = ref(false);

        const saveUserInfo = async (data) => {
            hwLoading.value = true;
            try {
                const userId = authStore.userConfig?.userId;
                if (!userId) return;

                // Save to cloud
                await axios.post('/api/update-user-info', {
                    userId,
                    height: data.height,
                    weight: data.weight
                });

                // Update local
                authStore.updateConfig({
                    height: data.height,
                    weight: data.weight
                });
                
                isHWModalOpen.value = false;
            } catch (e) {
                console.error('Failed to save user info:', e);
                alert('‰øùÂ≠òÂ§±Ë¥•ÔºåËØ∑ÈáçËØï');
            } finally {
                hwLoading.value = false;
            }
        };

        // --- Swipe to Delete Logic ---
        const swipeActiveId = ref(null);
        const swipeOffset = ref(0);
        const isSwipeDragging = ref(false);
        const swipeStartX = ref(0);

        const onSwipeStart = (e, id) => {
            if (swipeActiveId.value && swipeActiveId.value !== id) {
                swipeActiveId.value = null;
                swipeOffset.value = 0;
            }

            if (swipeActiveId.value === id) {
                swipeStartX.value = e.touches[0].clientX - swipeOffset.value;
            } else {
                swipeActiveId.value = id;
                swipeStartX.value = e.touches[0].clientX;
                swipeOffset.value = 0;
            }
            isSwipeDragging.value = true;
        };

        const onSwipeMove = (e) => {
            if (!isSwipeDragging.value || !swipeActiveId.value) return;
            
            const currentX = e.touches[0].clientX;
            const diff = currentX - swipeStartX.value;
            
            if (diff < -80) swipeOffset.value = -80;
            else if (diff > 0) swipeOffset.value = 0;
            else swipeOffset.value = diff;
        };

        const onSwipeEnd = () => {
            isSwipeDragging.value = false;
            if (!swipeActiveId.value) return;

            if (swipeOffset.value < -40) {
                swipeOffset.value = -80; 
            } else {
                swipeOffset.value = 0;   
                swipeActiveId.value = null;
            }
        };

        const getSwipeStyle = (id) => {
            if (swipeActiveId.value === id) {
                return {
                    transform: `translateX(${swipeOffset.value}px)`,
                    transition: isSwipeDragging.value ? 'none' : 'transform 0.3s cubic-bezier(0.25, 0.8, 0.5, 1)'
                };
            }
            return {
                transition: 'transform 0.3s cubic-bezier(0.25, 0.8, 0.5, 1)'
            };
        };

        // Load preferred actions and Init
        onMounted(async () => {
            // 1. Initialize Theme
            document.documentElement.setAttribute('data-theme', currentTheme.value);

            // 2. Load Preferred Actions
            // Priority: LocalStorage -> UserConfig (fallback)
            let loaded = false;
            const local = localStorage.getItem('preferredActions');
            if (local) {
                try {
                    preferredActions.value = JSON.parse(local);
                    loaded = true;
                } catch(e) {}
            }
            
            if (!loaded) {
                const config = authStore.userConfig;
                if (config && config.preferredAction && Array.isArray(config.preferredAction) && config.preferredAction.length > 0) {
                    preferredActions.value = config.preferredAction;
                }
            }

            // 3. Check and Fetch User Info (Height & Weight)
            const config = authStore.userConfig;
            if (config) {
                if (!config.weight || !config.height) {
                    try {
                        const res = await axios.post('/api/get-user-info', { userId: config.userId });
                        if (res.data.success) {
                            const cloudConfig = res.data.userConfig;
                            // Check if cloud has info
                            if (cloudConfig.weight && cloudConfig.height) {
                                authStore.updateConfig(cloudConfig);
                            } else {
                                // Cloud also missing -> Prompt
                                isHWModalOpen.value = true;
                            }
                        }
                    } catch (e) {
                        console.error('Failed to update user info:', e);
                        // Optional: if network error, maybe prompt anyway? 
                        // Assuming if check fails we might want to prompt if we really need it,
                        // but let's stick to "if cloud also no data". If network fail, we don't know if cloud has data.
                        // For safety, maybe just do nothing on network error, try again next load.
                    }
                }
            }

            // 4. Fetch Data
            await fetchActions();
            await fetchHistory('today');
        });

        const getCategoryMatch = (action, category) => {
            const cat = action.target_muscle_group || '';
            return cat.includes(category) || 
                   (category === 'ËÖø' && cat.includes('Leg')) ||
                   (category === 'Ê†∏ÂøÉ' && (cat.includes('ËÖπ') || cat.includes('Abs'))) ||
                   (category === 'ÊâãËáÇ' && cat.includes('ËáÇ'));
        };

        // Computed: Actions in current category that are preferred
        const filteredPreferredActions = computed(() => {
            return allActions.value.filter(a => {
                const matchCategory = getCategoryMatch(a, activeCategory.value);
                return matchCategory && preferredActions.value.includes(a.id);
            });
        });

        // Computed: All actions in current category (for modal)
        const currentCategoryActions = computed(() => {
            return allActions.value.filter(a => {
                return getCategoryMatch(a, activeCategory.value);
            });
        });
        
        // Computed: Initial selected IDs for modal
        const initialModalSelected = computed(() => {
            // We want to pass IDs that are currently preferred AND in this category
            // But actually, the modal should show ALL preferred IDs for this category as selected.
            // Which is exactly what filteredPreferredActions contains.
            return filteredPreferredActions.value.map(a => a.id);
        });

        const openPreferenceModal = () => {
            isPreferenceModalOpen.value = true;
        };

        const closePreferenceModal = () => {
            isPreferenceModalOpen.value = false;
        };

        const savePreferences = async (selectedIds) => {
            preferenceSaving.value = true;
            try {
                // Remove existing prefs for this category
                const currentCatActionIds = currentCategoryActions.value.map(a => a.id);
                const otherPreferences = preferredActions.value.filter(id => !currentCatActionIds.includes(id));
                
                // Add new prefs
                const newPreferredActions = [...otherPreferences, ...selectedIds];
                preferredActions.value = newPreferredActions;

                // Save locally
                localStorage.setItem('preferredActions', JSON.stringify(newPreferredActions));
                
                // Cloud sync removed per user request - Local Storage Only
                
                closePreferenceModal();
            } catch (error) {
                console.error('Failed to save preferences:', error);
                alert('‰øùÂ≠òÂ§±Ë¥•ÔºåËØ∑ÈáçËØï');
            } finally {
                preferenceSaving.value = false;
            }
        };

        const fetchActions = async (force = false) => {
            actionsLoading.value = true;
            try {
                // Check cache
                const cached = localStorage.getItem('cachedActions');
                if (!force && cached) {
                    allActions.value = JSON.parse(cached);
                    // If we have cache, we can still fetch in background to update, or just return.
                    // For now, if we have cache, we assume it's good unless forced.
                    if (allActions.value.length > 0) {
                        actionsLoading.value = false;
                        return;
                    }
                }

                const response = await axios.get('/api/get-actions');
                if (response.data.success) {
                    const mapped = response.data.data.map(item => {
                        
                        const name = item.name || 'Unknown';
                        const label = item.label || item.name;// Â¶ÇÊûúÊ≤°Êúâ label Â∞±Áî® name ÂÖúÂ∫ï
                        const desc = item.description || '';
                        const muscle = item.target_muscle_group || 'ÂÖ∂‰ªñ';
                        // Êà™ÂõæÈáå category ÊòØ‰∏™Êï∞ÁªÑ ["Ëá™Áî±ÈáçÈáè", "Â±ÖÂÆ∂"]ÔºåÂ¶ÇÊûúÊúâÁî®Âà∞‰πüÂèØ‰ª•Âèñ
                        // category: item.category || []
                        
                        // Assign icon/color based on muscle or random
                        let icon = 'üèãÔ∏è';
                        let color = 'bg-primary/5 text-primary';
                        
                        if (muscle.includes('ËÉ∏')) { icon = 'üí™'; color = 'bg-blue-100 text-blue-600'; }
                        else if (muscle.includes('ËÉå')) { icon = 'ü¶ç'; color = 'bg-purple-100 text-purple-600'; }
                        else if (muscle.includes('ËÖø') || muscle.includes('Leg')) { icon = 'ü¶µ'; color = 'bg-orange-100 text-orange-600'; }
                        else if (muscle.includes('ËÖπ') || muscle.includes('Abs')) { icon = 'üßò'; color = 'bg-green-100 text-green-600'; }
                        else if (muscle.includes('ËÇ©')) { icon = 'ü§∑'; color = 'bg-red-100 text-red-600'; }
                        else if (muscle.includes('ËáÇ')) { icon = 'ü¶æ'; color = 'bg-indigo-100 text-indigo-600'; }

                        return {
                            id: item.name, // Use name as unique ID since database has no ID column
                            name: name, // English Name (for saving)
                            label: label, // Chinese Label (for display)
                            description: desc,
                            target_muscle_group: muscle,
                            kcal: 0.3, // Default fallback
                            icon: icon,
                            color: color,
                            // New fields for calorie calculation
                            met: item.met,
                            seconds_per_rep: item.seconds_per_rep,
                            calc_mode: item.calc_mode,
                            // Pre-calculate Pinyin for voice matching
                            pinyinLabel: pinyin(label, { toneType: 'none', type: 'array' }).join('').toLowerCase()
                        };
                    });
                    
                    allActions.value = mapped;
                    localStorage.setItem('cachedActions', JSON.stringify(mapped));

                    // Initialize ActionMatcher
                    if (window.ActionMatcher) {
                        actionMatcher = new window.ActionMatcher(mapped);
                    }
                }
            } catch (e) {
                console.error('Failed to fetch actions:', e);
                // Fallback to hardcoded if empty?
                if (allActions.value.length === 0) {
                     allActions.value = [
                        { id: 'pull_ups', name: 'Pull Up', label: 'Âºï‰ΩìÂêë‰∏ä', kcal: 0.5, icon: 'üí™', color: 'bg-blue-100 text-blue-600', target_muscle_group: 'ËÉåÈÉ®' },
                        { id: 'push_ups', name: 'Push Up', label: '‰øØÂçßÊíë', kcal: 0.2, icon: 'ü§∏', color: 'bg-purple-100 text-purple-600', target_muscle_group: 'ËÉ∏ÈÉ®' }
                     ];
                }
            } finally {
                actionsLoading.value = false;
            }
        };

        const groupedActions = computed(() => {
            const groups = {};
            // Sort by muscle group to ensure consistent order if needed
            allActions.value.forEach(action => {
                const groupName = action.target_muscle_group || 'ÂÖ∂‰ªñ';
                if (!groups[groupName]) groups[groupName] = [];
                groups[groupName].push(action);
            });
            return groups;
        });

        // Cleaned up duplicate onMounted

        const fetchHistory = async (range = 'today') => {
            const config = authStore.userConfig?.configuration;
            const userId = authStore.userConfig?.userId;
            
            if (!config || !userId) {
                initLoading.value = false;
                return;
            }

            if (range === 'all') historyLoading.value = true;

            try {
                const response = await axios.post('/api/get-history', {
                    userId: userId,
                    appToken: config.fs_app_token,
                    tableId: config.fs_table_id,
                    range: range
                });

                if (response.data.success) {
                    const mappedData = response.data.data.map(item => {
                        const fields = item.fields;
                        // Handle Feishu text field format (array of objects or direct string)
                        let actionId = fields.training_types;
                        if (Array.isArray(actionId) && actionId.length > 0 && actionId[0].text) {
                            actionId = actionId[0].text;
                        }
                        
                        const action = allActions.value.find(a => a.name === actionId || a.label === actionId || a.id === actionId);
                        
                        let kcal = fields.calories || fields.Kcal_Burned;
                        if (!kcal && action) {
                            kcal = (fields.count * action.kcal).toFixed(1);
                        }

                        return {
                            id: item.id,
                            date: item.createdTime,
                            actionType: action ? action.label : actionId,
                            count: fields.count,
                            kcal: kcal || 0
                        };
                    });

                    if (range === 'today') {
                        const todayStr = new Date().toDateString();
                        history.value = mappedData.filter(item => {
                            const d = new Date(item.date);
                            return d.toDateString() === todayStr;
                        });
                    } else {
                        allHistory.value = mappedData;
                    }
                }
            } catch (error) {
                console.error('Failed to fetch history:', error);
            } finally {
                initLoading.value = false;
                if (range === 'all') historyLoading.value = false;
            }
        };

        const switchTab = async (tab) => {
            activeTab.value = tab;
            if (tab === 'history' && allHistory.value.length === 0) {
                await fetchHistory('all');
            }
            if (tab === 'pump' && pumpData.value.length === 0) {
                await fetchPumpData();
            }
        };

        // --- Pump Logic ---
        const fetchPumpData = async () => {
            pumpLoading.value = true;
            try {
                const response = await axios.get('/api/get-pump');
                if (response.data.success && response.data.data) {
                    // Shuffle the data
                    const items = response.data.data;
                    for (let i = items.length - 1; i > 0; i--) {
                        const j = Math.floor(Math.random() * (i + 1));
                        [items[i], items[j]] = [items[j], items[i]];
                    }
                    
                    
                    // Map fields
                    pumpData.value = items.map(item => ({
                        id: item.id,
                        title: item.title ? item.title : '',
                        content: item.content ? item.content : '',
                        cover: item.cover ? item.cover : null,
                        category: item.categroy ? item.categroy : '', // Note: 'categroy' typo in user input/field name
                        music: item.music ? item.music : null
                    }));
                    currentCardIndex.value = 0;
                    console.log(pumpData.value)
                }
            } catch (error) {
                console.error('Failed to fetch pump data:', error);
            } finally {
                pumpLoading.value = false;
            }
        };

        const currentCard = computed(() => {
            if (pumpData.value.length === 0) return {};
            return pumpData.value[currentCardIndex.value] || {};
        });

        const cardStyle = computed(() => {
            if (isResetting.value) return { transform: 'none', transition: 'none' };
            
            // If dragging, follow finger (no transition). If animating (fly out/snap back), use transition.
            const transition = isDragging.value ? 'none' : 'transform 0.3s ease-out';
            return {
                transform: `translate(${cardX.value}px, ${cardY.value}px) rotate(${cardRotation.value}deg)`,
                transition: transition
            };
        });

        const titleClass = computed(() => {
            const title = currentCard.value.title || '';
            const len = title.length;
            
            if (len <= 4) return 'text-5xl';
            if (len <= 8) return 'text-4xl';
            if (len <= 15) return 'text-3xl';
            if (len <= 25) return 'text-2xl';
            return 'text-xl';
        });

        // Card Swipe Handlers
        let startX = 0;
        let startY = 0;

        const onCardTouchStart = (e) => {
            if (isAnimating.value) return;
            isDragging.value = true;
            const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
            const clientY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
            startX = clientX;
            startY = clientY;
        };

        const onCardTouchMove = (e) => {
            if (!isDragging.value) return;
            e.preventDefault(); // Prevent scrolling
            const clientX = e.type.includes('mouse') ? e.clientX : e.touches[0].clientX;
            const clientY = e.type.includes('mouse') ? e.clientY : e.touches[0].clientY;
            
            const deltaX = clientX - startX;
            const deltaY = clientY - startY;
            
            cardX.value = deltaX;
            cardY.value = deltaY;
            cardRotation.value = deltaX * 0.1; // Rotate based on X movement
        };

        const onCardTouchEnd = (e) => {
            if (!isDragging.value) return;
            isDragging.value = false;
            
            const threshold = window.innerWidth / 3;
            if (Math.abs(cardX.value) > threshold) {
                // Swipe Out
                isAnimating.value = true;
                const direction = cardX.value > 0 ? 1 : -1;
                const screenWidth = window.innerWidth;
                
                // Fly out
                cardX.value = direction * screenWidth * 1.5;
                cardRotation.value = direction * 45;
                
                // Wait for animation then switch
                setTimeout(() => {
                    nextCard();
                    
                    // Instant reset without animation
                    isResetting.value = true;
                    cardX.value = 0;
                    cardY.value = 0;
                    cardRotation.value = 0;
                    isAnimating.value = false;
                    
                    setTimeout(() => {
                        isResetting.value = false;
                    }, 50);
                }, 300);
            } else {
                // Snap back
                isAnimating.value = true;
                cardX.value = 0;
                cardY.value = 0;
                cardRotation.value = 0;
                
                setTimeout(() => {
                    isAnimating.value = false;
                }, 300);
            }
        };

        const nextCard = () => {
            if (currentCardIndex.value < pumpData.value.length - 1) {
                currentCardIndex.value++;
            } else {
                // Loop back or fetch more? Loop for now
                currentCardIndex.value = 0;
                // Reshuffle?
            }
        };

        // --- End Pump Logic ---

        const heatmapData = computed(() => {
             if (allHistory.value.length === 0) return [];
             
             // Generate last 365 days
             const days = [];
             const today = new Date();
             const oneYearAgo = new Date();
             oneYearAgo.setDate(today.getDate() - 364);
             
             // Pad start to align with day of week (assuming Row 1 is Sunday)
             const startDay = oneYearAgo.getDay(); // 0-6
             for (let i = 0; i < startDay; i++) {
                 days.push({ date: '', count: 0, color: 'bg-transparent', invisible: true });
             }

             // Create map of date -> count
             const activityMap = {};
             allHistory.value.forEach(record => {
                 const dateStr = new Date(record.date).toDateString();
                 if (!activityMap[dateStr]) activityMap[dateStr] = 0;
                 activityMap[dateStr]++;
             });
 
             for (let d = new Date(oneYearAgo); d <= today; d.setDate(d.getDate() + 1)) {
                 const dateStr = d.toDateString();
                 const count = activityMap[dateStr] || 0;
                 let color = 'bg-base-200'; // default gray
                 if (count > 0) color = 'bg-green-200';
                 if (count > 2) color = 'bg-green-400';
                 if (count > 5) color = 'bg-green-600';
                 
                 days.push({
                     date: d.toLocaleDateString(),
                     count,
                     color,
                     invisible: false
                 });
             }
             return days;
         });

        const historyStatsText = computed(() => {
            const currentMonth = new Date().getMonth();
            const currentYear = new Date().getFullYear();
            
            const thisMonthRecords = allHistory.value.filter(record => {
                const d = new Date(record.date);
                return d.getMonth() === currentMonth && d.getFullYear() === currentYear;
            });

            const uniqueDays = new Set(thisMonthRecords.map(r => new Date(r.date).toDateString())).size;
            const totalSets = thisMonthRecords.length;

            return `Êú¨ÊúàÂÖ±ËøêÂä® ${uniqueDays} Â§©ÔºåÂÆåÊàêËøêÂä® ${totalSets} ÁªÑ`;
        });

        const todayRecords = computed(() => {
          const today = new Date().toDateString();
          return history.value.filter(record => new Date(record.date).toDateString() === today);
        });

        const todayKcal = computed(() => {
          return todayRecords.value.reduce((sum, record) => sum + parseFloat(record.kcal), 0).toFixed(1);
        });

        const todaySets = computed(() => todayRecords.value.length);

        const openModal = (action) => {
          currentAction.value = action;
          isModalOpen.value = true;
        };

        const closeModal = () => {
          isModalOpen.value = false;
          // Reset Voice/Auto Submit State
          isModalAutoSubmit.value = false;
          initialModalCount.value = null;
          initialModalWeight.value = null;
        };

        const lastRecordParams = ref(null);
        const repeatLoading = ref(false);
        const repeatSuccess = ref(false);

        // Core submission logic (reused)
        const submitRecord = async (action, count, estimatedKcal, weightLifted) => {
             const config = authStore.userConfig?.configuration;
             const userId = authStore.userConfig?.userId;

             if (!config || !userId) {
                 throw new Error("Missing config");
             }

             const response = await axios.post('/api/submit-record', {
                  userId: userId,
                  appToken: config.fs_app_token,
                  tableId: config.fs_table_id,
                  trainingType: action.name,
                  count: count,
                  weightLifted: parseInt(weightLifted),
                  calories: Math.round(parseFloat(estimatedKcal))
             });

             if (response.data.success) {
                 const newRecord = response.data.data;
                 const createdMs = newRecord.created_at * 1000;
                 const actionName = action.name;
                 const actionDef = allActions.value.find(a => a.name === actionName);
                 const kcal = newRecord.calories || estimatedKcal || 0;
                 
                 const localRecord = {
                     id: newRecord.id,
                     date: createdMs,
                     actionType: actionDef ? actionDef.label : actionName,
                     count: newRecord.count,
                     kcal: kcal
                 };
                 
                 history.value.unshift(localRecord);
                 if (allHistory.value.length > 0) {
                     allHistory.value.unshift(localRecord);
                 }
                 
                 // Play finish sound
                 const audio = new Audio('resources/finish.mp3');
                 audio.play().catch(e => console.log('Audio play failed:', e));
             }
        };

        const handleConfirm = async (count, estimatedKcal, weightLifted) => {
          if (!currentAction.value.id) return;
          
          lastRecordParams.value = {
              action: { ...currentAction.value },
              count,
              estimatedKcal,
              weightLifted
          };

          loading.value = true;

          try {
            await submitRecord(currentAction.value, count, estimatedKcal, weightLifted);
            closeModal();
            isRestTimerOpen.value = true;
          } catch (error) {
            console.error('Failed to submit record:', error);
            if (error.message === "Missing config") {
                 alert("Cannot sync: Missing configuration.");
            } else {
                 alert('Failed to sync with server.');
            }
          } finally {
            loading.value = false;
          }
        };

        const handleRepeat = async () => {
            if (!lastRecordParams.value) return;
            
            repeatLoading.value = true;
            repeatSuccess.value = false;
            
            const { action, count, estimatedKcal, weightLifted } = lastRecordParams.value;
            
            try {
                await submitRecord(action, count, estimatedKcal, weightLifted);
                
                repeatSuccess.value = true;
                setTimeout(() => {
                    repeatSuccess.value = false;
                }, 1500);
            } catch (error) {
                console.error('Repeat failed:', error);
                alert('ÈáçËØïÂ§±Ë¥•ÔºåËØ∑Ê£ÄÊü•ÁΩëÁªú');
            } finally {
                repeatLoading.value = false;
            }
        };

        const deleteRecord = async (id) => {
          if (confirm('Á°ÆËÆ§Âà†Èô§ËøôÊù°ËÆ∞ÂΩïÂêóÔºü')) {
            deletingId.value = id;
            try {
                const config = authStore.userConfig?.configuration;
                const userId = authStore.userConfig?.userId;
                
                if (config && userId) {
                    await axios.post('/api/delete-record', {
                        userId: userId,
                        appToken: config.fs_app_token,
                        tableId: config.fs_table_id,
                        recordId: id
                    });
                    
                    // Remove from local list after successful backend deletion
                    history.value = history.value.filter(item => item.id !== id);
                } else {
                    alert("ÈÖçÁΩÆÁº∫Â§±ÔºåÊó†Ê≥ïÂà†Èô§‰∫ëÁ´ØËÆ∞ÂΩï„ÄÇ");
                }
            } catch (error) {
                console.error("Failed to delete record:", error);
                alert("Âà†Èô§‰∫ëÁ´ØËÆ∞ÂΩïÂ§±Ë¥•„ÄÇ");
            } finally {
                deletingId.value = null;
            }
          }
        };

        // Duplicate handleRepeat removed

        const logout = () => {
          authStore.logout();
          localStorage.removeItem('cachedActions');
          localStorage.removeItem('userConfig');
          router.push('/login');
        };

        const userInitial = computed(() => {
            const name = authStore.userConfig?.username || authStore.userConfig?.nickname || 'Athlete';
            try {
                if (Array.isArray(name)) {
                    return String(name[0]?.text || name[0] || 'U').charAt(0).toUpperCase();
                }
                return String(name).charAt(0).toUpperCase();
            } catch (e) {
                return 'U';
            }
        });

        const getIcon = (name) => {
          const action = allActions.value.find(a => a.label === name || a.name === name);
          return action ? action.icon : 'üìù';
        };

        const getActionColor = (name) => {
            const action = allActions.value.find(a => a.label === name || a.name === name);
            return action ? action.color : 'bg-gray-100 text-gray-600';
        }

        const formatTime = (dateStr) => {
          return new Date(dateStr).toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        };

        return { 
          // Voice Assistant
          isListening,
          voiceTranscript,
          startListening,
          stopListening,
          initialModalCount,
          initialModalWeight,
          isModalAutoSubmit,

          handleRepeat,
          repeatLoading,
          repeatSuccess,
          authStore, 
          history, 
          isModalOpen, 
          currentAction, 
          loading, 
          initLoading, 
          allActions,
          groupedActions,
          fetchActions,
          actionsLoading,
          todayRecords, 
          todayKcal, 
          todaySets,
          openModal, 
          closeModal, 
          handleConfirm, 
          deleteRecord, 
          logout,
          getIcon, 
          getActionColor, 
          formatTime, 
          userInitial, 
          deletingId,
          isRestTimerOpen,
          activeTab,
          switchTab,
          heatmapData,
          historyStatsText,
          allHistory,
          historyLoading, // Added this
          // Preferences
          categories,
          activeCategory,
          filteredPreferredActions,
          openPreferenceModal,
          closePreferenceModal,
          isPreferenceModalOpen,
          currentCategoryActions,
          initialModalSelected,
          preferenceSaving,
          savePreferences,
          // Theme
          themes: [
            { name: 'ÈªòËÆ§Á¥´', value: 'light', color: '#6366f1' },
            { name: 'Ê¥ªÂäõÁ∫¢', value: 'valentine', color: '#ef4444' },
            { name: 'ÊûÅÂ§úÈªë', value: 'black', color: '#1f2937' },
            { name: 'Ëá™ÁÑ∂Áªø', value: 'emerald', color: '#10b981' },
            { name: 'Â§©Á©∫Ëìù', value: 'corporate', color: '#3b82f6' },
            { name: 'ÊöñÈò≥Ê©ô', value: 'halloween', color: '#f97316' },
            { name: 'ÈùíËâ≤', value: 'aqua', color: '#06b6d4' }
          ],
          currentTheme,
          setTheme,
          // Pump
          pumpData,
          currentCard,
          cardStyle,
          pumpLoading,
          onCardTouchStart,
          onCardTouchMove,
          onCardTouchEnd,
          fetchPumpData,
          titleClass,
          // HW Modal
          isHWModalOpen,
          hwLoading,
          saveUserInfo,
          // Swipe Logic
          swipeActiveId,
          swipeOffset,
          isSwipeDragging,
          onSwipeStart,
          onSwipeMove,
          onSwipeEnd,
          getSwipeStyle
        };
      }
    });

    // --- Router ---
    const router = createRouter({
      history: createWebHashHistory(),
      routes: [
        {
          path: '/login',
          name: 'Login',
          component: Login,
        },
        {
          path: '/',
          name: 'Dashboard',
          component: Dashboard,
          meta: { requiresAuth: true },
        },
      ],
    });

    router.beforeEach((to, from, next) => {
      const authStore = useAuthStore();
      if (to.meta.requiresAuth && !authStore.userConfig) {
        next('/login');
      } else if (to.path === '/login' && authStore.userConfig) {
        next('/');
      } else {
        next();
      }
    });

    // --- App Initialization ---
    const app = createApp({
      setup() {
        return {};
      }
    });

    app.use(createPinia());
    app.use(router);
    app.mount('#app');
  </script>
</body>
</html>
